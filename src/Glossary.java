import java.util.Comparator;

import components.queue.Queue;
import components.queue.Queue1L;
import components.set.Set;
import components.set.Set1L;
import components.simplereader.SimpleReader;
import components.simplereader.SimpleReader1L;
import components.simplewriter.SimpleWriter;
import components.simplewriter.SimpleWriter1L;

/**
 * Put a short phrase describing the program here.
 *
 * @author Caleb Arendse
 *
 */
public final class Glossary {

    /**
     * Private constructor so this utility class cannot be instantiated.
     */
    private Glossary() {
    }

    /**
     * Outputs the "index.html" to given output stream. These are the expected
     * elements generated by this method:
     *
     * <html> <head> <title>Sample Glossary</title> </head> <body>
     * <h2>the page title</h2>
     * <hr/>
     * <h3>Index</h3>
     * <ul>
     *
     * </body> </html>
     *
     * @param out
     *            the output stream
     * @updates out.contents
     * @requires out.is_open
     * @ensures out.content = #out.content * [the HTML "closing" tags]
     */
    public static void generateIndexHeader(SimpleWriter out) {
        out.println("<html>");
        out.println("<head>");
        out.println("<title>" + "Sample Glossary" + "</title>");
        out.println("</head>");
        out.println("<body>");
        out.println("<h2>" + "Sample Glossary" + "</h2>");
        out.println("<hr/>");
        out.println("<h3>" + "Index" + "</h3>");
        out.println("<ul>");
    }

    /**
     * Outputs to given output file stream a list element from the given word.
     * These are the expected elements generated by this method:
     * <li><a href=/"" + given word + ".html\">" + given word + "</a></li> \n
     *
     *
     * @param out
     *            the output stream
     * @param word
     *            the given word
     *
     * @updates out.contents
     * @requires out.is_open
     * @ensures out.content = #out.content * [the HTML "closing" tags]
     */
    public static void generateListElement(SimpleWriter out, String word) {
        out.print("<li><a href=\"" + word);
        out.print(".html\">" + word + "</a></li>\n");

    }

    /**
     * Outputs a html page with definition of given word and links to other word
     * page of words in definition and glossary, ending with link to return to
     * index html page to given output stream for the given word. These are the
     * expected elements generated by this method:
     *
     * <html> <head> <title>given word</title> </head> <body>
     * <h2><b><i><font color = "red"> + word + </font></i></b></h2> <blockquote>
     * given definition with links to other word page of words in definition and
     * glossary <blockquote>
     * <hr/>
     * <p>
     * Return to <a href=index.html>index</a>.
     * </p>
     *
     * @param out
     *            the output stream
     * @param word
     *            given word
     * @param definition
     *            definition of given word
     * @param glossary
     *            collection of known words
     *
     * @updates out.contents
     * @requires out.is_open
     * @ensures out.content = #out.content * [the HTML "closing" tags]
     */
    public static void generateWordHeader(SimpleWriter out, String word,
            String definition, Queue<String> glossary) {
        int position = 0;
        //boolean to track if word in definition is in glossary queue
        boolean isIn = false;

        //Generate separator set with space and comma
        Set<Character> sSet = new Set1L<>();
        generateElements(" ,", sSet);

        //Prints tags to given html file output stream
        out.println("<html>");
        out.println("<head>");
        out.println("<title>" + word + "</title>");
        out.println("</head>");
        out.println("<body>");
        out.println("<h2><b><i><font color = \"red\">" + word
                + "</font></i></b></h2>");
        out.print("<blockquote>");

        //loop through definition string
        while (position < definition.length()) {
            //Generate string with next word or separator
            String t = nextWordOrSeparator(definition, position, sSet);

            //checks if the word generated above from the definition string is
            //in the glossary queue

            for (String y : glossary) {
                if (t.equals(y)) {
                    //Generates link to word if in glossary in given html file
                    //output steam.

                    out.print("<a href=\"" + t + ".html\">" + t + "</a>");

                    //Sets isIn to true since word is in glossary
                    isIn = true;
                }
            }
            //checks if isIn is false therefore printing word string without
            //link to given html file output stream

            if (!isIn) {
                out.print(t);
            }

            position += t.length();
            //Resets isIn boolean
            isIn = false;
        }

        //Prints remaining tags to given html file output steam
        out.println("</blockquote>");
        out.println("<hr/>");
        out.println("<p>Return to <a href=\"index.html\">index</a>.</p>");

    }

    /**
     * Outputs end tags in generated index HTML file. These are the expected
     * elements generated by this method:
     *
     * </ul>
     * </body> </html>
     *
     * @param out
     *            the output stream
     * @updates out.contents
     * @requires out.is_open
     * @ensures out.content = #out.content * [the HTML "closing" tags]
     */
    public static void generateIndexFooter(SimpleWriter out) {
        out.println("</ul>");
        out.println("</body>");
        out.println("</html>");
    }

    /**
     * Outputs end tags in generated word HTML file output steam. These are the
     * expected elements generated by this method:
     *
     *
     * </body> </html>
     *
     * @param out
     *            the output stream
     * @updates out.contents
     * @requires out.is_open
     * @ensures out.content = #out.content * [the HTML "closing" tags]
     */
    public static void generateWordPageFooter(SimpleWriter out) {

        out.println("</body>");
        out.println("</html>");
    }

    /**
     * Generates the set of characters in the given {@code String} into the
     * given {@code Set}.
     *
     * @param str
     *            the given {@code String}
     * @param charSet
     *            the {@code Set} to be replaced
     * @replaces charSet
     * @ensures charSet = entries(str)
     */
    public static void generateElements(String str, Set<Character> charSet) {

        for (int i = 0; i < str.length(); i++) {
            if (charSet.size() > 0) {
                if (!charSet.contains(str.charAt(i))) {
                    charSet.add(str.charAt(i));
                }
            } else {
                charSet.add(str.charAt(i));
            }

        }

    }

    /**
     * Returns the first "word" (maximal length string of characters not in
     * {@code separators}) or "separator string" (maximal length string of
     * characters in {@code separators}) in the given {@code text} starting at
     * the given {@code position}.
     *
     * @param text
     *            the {@code String} from which to get the word or separator
     *            string
     * @param position
     *            the starting index
     * @param separators
     *            the {@code Set} of separator characters
     * @return the first word or separator string found in {@code text} starting
     *         at index {@code position}
     * @requires 0 <= position < |text|
     * @ensures <pre>
     * nextWordOrSeparator =
     *   text[position, position + |nextWordOrSeparator|)  and
     * if entries(text[position, position + 1)) intersection separators = {}
     * then
     *   entries(nextWordOrSeparator) intersection separators = {}  and
     *   (position + |nextWordOrSeparator| = |text|  or
     *    entries(text[position, position + |nextWordOrSeparator| + 1))
     *      intersection separators /= {})
     * else
     *   entries(nextWordOrSeparator) is subset of separators  and
     *   (position + |nextWordOrSeparator| = |text|  or
     *    entries(text[position, position + |nextWordOrSeparator| + 1))
     *      is not subset of separators)
     * </pre>
     */
    public static String nextWordOrSeparator(String text, int position,
            Set<Character> separators) {

        String t = text.substring(position);
        String result = "";

        for (int i = 0; i < t.length(); i++) {
            int index = i;
            for (char s : separators) {
                if (t.charAt(index) == s && t.charAt(0) != s) {
                    result = t.substring(0, index);
                    i = t.length();
                } else if (t.charAt(index) == s) {
                    result = t.substring(0, index + 1);
                    i = t.length();
                }
            }

        }

        if (result.isEmpty()) {
            result = t;
        }

        return result;
    }

    /**
     * Main method.
     *
     * @param args
     *            the command line arguments
     */
    public static void main(String[] args) {
        SimpleReader in = new SimpleReader1L();
        SimpleWriter out = new SimpleWriter1L();

        //Creates object for comparator that sorts alphabetically
        Comparator<String> t = new SortComparator();

        //Prompts user for input file and creates output stream
        out.print("Enter input filename: ");
        SimpleReader gloss = new SimpleReader1L(in.nextLine());

        //Prompts user for output location
        out.print("Enter output location: ");
        String outputFile = in.nextLine();

        //Create Queues for Words and Definitions
        Queue<String> words = new Queue1L<>();
        Queue<String> defintions = new Queue1L<>();

        //Read lines from given file
        while (!gloss.atEOS()) {
            String k = gloss.nextLine();
            //Checks if string is a word (does not contain whitespace) or
            //definition (contains whitespace) also if the definition ends with
            //comma the definition continues on the next line.

            if (!k.isEmpty() && !k.contains(" ")) {
                words.enqueue(k);
            } else if (k.contains(" ")) {
                if (k.charAt(k.length() - 1) == ',') {
                    defintions.enqueue(k + " " + gloss.nextLine());
                } else {
                    defintions.enqueue(k);
                }
            }
        }

        //Create output stream for index file and generate header of index
        SimpleWriter index = new SimpleWriter1L(outputFile + "/index.html");
        generateIndexHeader(index);

        //Loop through words in word Queue
        for (String word : words) {
            //Create output steam to html file for given word
            SimpleWriter page = new SimpleWriter1L(
                    outputFile + "/" + word + ".html");

            //Generate header for word html file with definition and respective links
            generateWordHeader(page, word, defintions.dequeue(), words);

            //Generate footer for word html page
            generateWordPageFooter(page);
        }
        //Sort words in to alphabetical order
        words.sort(t);

        //Loop through words again now that in alphabetical order
        for (String o : words) {
            //Generate list element in index html file with ordered words queue
            //to index html file output steam

            generateListElement(index, o);
        }

        //Generates footer for index html file
        generateIndexFooter(index);

        /*
         * Close input and output streams
         */
        gloss.close();
        in.close();
        out.close();
    }

}
